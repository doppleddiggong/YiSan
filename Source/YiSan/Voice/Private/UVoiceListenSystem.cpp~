// Copyright (c) 2025 Doppleddiggong. All rights reserved. Unauthorized copying, modification, or distribution of this file, via any medium is strictly prohibited. Proprietary and confidential.


#include "UVoiceListenSystem.h"

#include "GameLogging.h"
#include "UVoiceFunctionLibrary.h"
#include "UWebSocketSystem.h"
#include "Sound/SoundWaveProcedural.h"
#include "Components/AudioComponent.h"
#include "Kismet/GameplayStatics.h"

UVoiceListenSystem::UVoiceListenSystem()
{
	PrimaryComponentTick.bCanEverTick = false;
}

void UVoiceListenSystem::InitSystem()
{
	// 오디오 컴포넌트 생성
	AudioComponent = NewObject<UAudioComponent>(this);
	AudioComponent->RegisterComponent();
	
	if (auto WebSocketSystem = UWebSocketSystem::Get(GetWorld()))
	{
		WebSocketSystem->OnAudioStart.AddDynamic(this, &UVoiceListenSystem::HandleAudioStart);
		WebSocketSystem->OnAudioChunkReceived.AddDynamic(this, &UVoiceListenSystem::HandleAudioChunk);
		WebSocketSystem->OnAudioEnd.AddDynamic(this, &UVoiceListenSystem::HandleAudioEnd);
	}
}

void UVoiceListenSystem::HandleAudioStart()
{
	UE_LOG(LogTemp, Warning, TEXT("HandleAudioStart: 오디오 스트림 시작. 재생을 준비합니다."));

	ProceduralSoundWave = NewObject<USoundWaveProcedural>();
	if (ProceduralSoundWave)
	{
		// 서버에서 보내주는 오디오 포맷에 맞춰야 합니다. (예: 16kHz, 모노)
		ProceduralSoundWave->SetSampleRate(16000);
		ProceduralSoundWave->NumChannels = 1;
		ProceduralSoundWave->Duration = INDEFINITELY_LOOPING_DURATION; // 스트리밍이므로 길이를 무한으로 설정
		ProceduralSoundWave->SoundGroup = ESoundGroup::SOUNDGROUP_Voice;
		ProceduralSoundWave->bLooping = false;

		if (AudioComponent)
		{
			AudioComponent->SetSound(ProceduralSoundWave);
			AudioComponent->Play();
		}
	}
}

void UVoiceListenSystem::HandleAudioChunk(const TArray<uint8>& AudioData)
{
	if (ProceduralSoundWave && AudioComponent && AudioComponent->IsPlaying())
	{
		// 받은 오디오 데이터 조각을 사운드 웨이브의 큐에 추가합니다.
		ProceduralSoundWave->QueueAudio(AudioData.GetData(), AudioData.Num());
	}
}

void UVoiceListenSystem::HandleAudioEnd()
{
	PRINTLOG( TEXT("HandleAudioEnd: 오디오 스트림이 종료되었습니다."));
	// 큐에 데이터가 더 이상 추가되지 않으면 재생이 자연스럽게 멈춥니다.
}


// Static helper functions for WAV parsing
static uint32 ReadUInt32(const uint8* Data, int32 Offset)
{
    return Data[Offset] |
           (Data[Offset + 1] << 8) |
           (Data[Offset + 2] << 16) |
           (Data[Offset + 3] << 24);
}

static uint16 ReadUInt16(const uint8* Data, int32 Offset)
{
    return Data[Offset] | (Data[Offset + 1] << 8);
}

void UVoiceListenSystem::HandleTTSOutput(const TArray<uint8>& AudioData, UObject* WorldContextObject)
{
	const FString SavePath = FPaths::ProjectSavedDir() / TEXT("TTS_Output.wav");

	if (FFileHelper::SaveArrayToFile(AudioData, *SavePath))
	{
		PRINTLOG(TEXT("TTS WAV 저장 완료: %s"), *SavePath);

		if (AudioData.Num() < 44)
		{
			PRINTLOG(TEXT("Invalid WAV data (too small)"));
			return;
		}

		const uint8* RawData = AudioData.GetData();

		// --- WAV Header Parsing ---
		uint16 NumChannels = ReadUInt16(RawData, 22);
		uint32 SampleRate = ReadUInt32(RawData, 24);

		// Find the 'data' chunk, as it's not always at a fixed position.
		int32 DataChunkOffset = 36; // Typically after the 'fmt ' chunk.
		while (DataChunkOffset + 8 < AudioData.Num())
		{
			// Read ChunkID as a 4-character string
			const char* ChunkIDStr = (const char*)(RawData + DataChunkOffset);
			
			if (strncmp(ChunkIDStr, "data", 4) == 0)
			{
				break; // Found it
			}

			// If not 'data', skip to the next chunk
			uint32 ChunkSize = ReadUInt32(RawData, DataChunkOffset + 4);
			DataChunkOffset += (8 + ChunkSize);
		}

		if (DataChunkOffset + 8 >= AudioData.Num())
		{
			PRINTLOG(TEXT("WAV 'data' chunk not found"));
			return;
		}

		const uint32 DataSize = ReadUInt32(RawData, DataChunkOffset + 4);
		const int32 DataStart = DataChunkOffset + 8;

		if (DataStart +  (int32)DataSize > AudioData.Num())
		{
			PRINTLOG(TEXT("Invalid WAV data chunk size"));
			return;
		}
		// --- End of WAV Header Parsing ---

		USoundWaveProcedural* SoundWave = NewObject<USoundWaveProcedural>();
		if (SoundWave)
		{
			SoundWave->SetSampleRate(SampleRate);
			SoundWave->NumChannels = NumChannels;
			SoundWave->Duration = INDEFINITELY_LOOPING_DURATION;
			SoundWave->SoundGroup = ESoundGroup::SOUNDGROUP_Voice;
			SoundWave->bLooping = false;

			// Queue the raw PCM data for playback
			SoundWave->QueueAudio(RawData + DataStart, DataSize);

			// Play the sound
			UGameplayStatics::PlaySound2D(WorldContextObject, SoundWave);
		}
		else
		{
			PRINTLOG(TEXT("Failed to create USoundWaveProcedural"));
		}
	}
	else
	{
		PRINTLOG(TEXT("TTS WAV 저장 실패"));
	}
}